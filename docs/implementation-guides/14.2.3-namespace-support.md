# Phase 2.3 — Translation Namespaces (Nested JSON)

Status: Implemented

This guide documents namespace support for translations using nested JSON objects that are flattened at runtime. It covers structure, migration, validation, testing, and usage.

- Location: src/app/locales/{en,ar,hi}.json
- Loader: src/lib/i18n.ts (loadTranslations → flattenTranslations)
- Utils: src/lib/translation-utils.ts
- Tests: tests/unit/i18n.namespace.test.tsx, tests/unit/translation-utils.namespace.test.ts
- CI Script: scripts/test-i18n.ts

## 1. Structure

Use nested JSON to group by feature/section. Keys are accessed with dot-notation.

Example:
{
  "nav": { "home": "Home", "about": "About" },
  "greeting": { "welcome": "Welcome, {{name}}!" },
  "portal": { "offline": { "title": "Offline queue" } }
}

Flattened (at runtime):
- nav.home
- nav.about
- greeting.welcome
- portal.offline.title

Gender variants remain suffix-based:
- greeting.welcome.male
- greeting.welcome.female
- greeting.welcome (fallback)

## 2. Loader Behavior

loadTranslations(locale) will:
- Import nested JSON
- Validate structure using validateNestedStructure
- Flatten to dot-notation via flattenTranslations
- Return a flat Record<string, string>

useTranslations().t(key, params) works with nested keys and gender fallback chains.

## 3. Migration Tips

- Group existing flat keys into logical sections (nav, footer, blog, portal, booking, contact, common, status, time, dashboard, range, role, tasks, prompt, pagination, priority, greeting, profile, notification, email, userProfile, etc.)
- Avoid arrays, nulls, numbers, and booleans in translation JSON; only strings and objects are allowed
- Do not change variable syntax; keep {{param}} placeholders intact
- Keep key names stable; only reorganize into nested objects
- Maintain parity across locales; if you nest a key in one locale, nest it the same way in the others

## 4. Validation & Parity

Run the parity/namespace validation script:
- pnpm tsx scripts/test-i18n.ts

What it checks:
- Arabic locale is RTL in localeConfig
- Nested JSON structure is valid in each locale
- Flat key parity across locales (ignoring locale-specific gender variants)
- Namespace shape parity (a path that is an object cannot be a leaf in another locale)

Utilities:
- flattenTranslations(obj)
- validateNestedStructure(obj)
- validateTranslationParity(locales, supportedGenders)

## 5. Testing

Unit tests ensure:
- flattenTranslations produces correct dot-notation keys
- useTranslations resolves nested keys and gender variants
- Fallback to base keys when gender-specific key is missing

Files:
- tests/unit/translation-utils.namespace.test.ts
- tests/unit/i18n.namespace.test.tsx

## 6. Usage Examples

// Access nested keys
const { t } = useTranslations()

h1: t('hero.headline')
button: t('portal.realtime.status.connected')

// With parameters and gender
p: t('greeting.welcome', { name: 'Alex', gender: 'male' })

## 7. Conventions

- Keys: lowerCamelCase segments with dot-notation; short and descriptive
- Grouping: by feature or page section
- Gender: suffix-based variants (.male, .female, .neuter) when applicable
- Placeholders: {{param}}; ensure placeholders exist in all locales

## 8. Troubleshooting

- Missing keys: run the i18n test script to list missing keys
- Shape mismatches: ensure a path is consistently an object or a leaf in all locales
- Unexpected output: confirm flattenTranslations output and check for typos in nested paths

## 9. Checklist

- [x] Nested JSON enabled and flattened on load
- [x] Parity and namespace shape validations in CI script
- [x] Tests for nested access and gender variants
- [x] Documentation published
